#include<stdio.h>
#include<sys/time.h>
#include<arm_neon.h>
#include<stdint.h>
#include<stdlib.h>

//you have to pass offset and size in units of byte/ size is a multiple of 8 and offset is a multiple of 2.
static inline int compute_ham_similarity(unsigned short* , unsigned short*,
                                int, int);
static inline int setbits(uint64x1_t );

int main(){
        struct timeval start, end;
        int i,size=600,offset=0;
        unsigned short reference[size/2], circ[size/2];
        for (i=0;i<size/2;i++){
                reference[i]=random();
                circ[(i+offset/2)%(size/2)]=random();
        }
      gettimeofday(&start,NULL);
//        int j=1000;
//      for(j;j>0;j--){ 
//              compute_ham_similarity(reference,circ,offset,size);
               int count=compute_ham_similarity(reference,circ,offset,size);
//      }
        gettimeofday(&end,NULL);
        printf("%ld seconds elapsed\n", end.tv_sec*1000000+(end.tv_usec)-start.tv_sec*1000000-(start.tv_usec));
	printf("%d\n",count);
}

static inline int setbits(uint64x1_t a){
        
	register uint8x8_t d= vcnt_u8(vreinterpret_u8_u64 (a));
//	printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t",vget_lane_u8 (d,0),vget_lane_u8 (d,1),vget_lane_u8 (d,2),vget_lane_u8 (d,3),vget_lane_u8 (d,4),vget_lane_u8 (d,5),vget_lane_u8 (d,6),vget_lane_u8 (d,7));
	return (int) (vget_lane_u8 (d,0)+ vget_lane_u8 (d,1)+ vget_lane_u8 (d,2)+
		      vget_lane_u8 (d,3)+ vget_lane_u8 (d,4)+ vget_lane_u8 (d,5)+
		      vget_lane_u8 (d,6)+ vget_lane_u8 (d,7) );
}

static inline int compute_ham_similarity(unsigned short* ref, unsigned short* circ_array, 
                                int off, int size){
	const uint64_t* ref_w=(uint64_t*) ref;
        const uint64_t* circ_w=(uint64_t*) circ_array;
        register uint64x1_t a,b,c,temp,temp1;
        register int i=0,count=0;
        int size_l=size/8,off_n;
        register int  diff;
        register int* ptr_circ=&off_n;
	int j=0;
	switch(off&0x7){
		case 0: 
			off_n=off>>3;
			struct timeval start, end;
			gettimeofday(&start,NULL);
			for(;*ptr_circ<size_l;){
				c=veor_u64(vld1_u64(&ref_w[i++]),vld1_u64(&circ_w[(*ptr_circ)++]));
				temp1=vadd_u64 (c,temp1);
			
			}
			*ptr_circ=0;
			for (;i<size_l;){
				c=veor_u64(vld1_u64(&ref_w[i++]),vld1_u64(&circ_w[(*ptr_circ)++]));
                                count=count+setbits(c);
			}
			gettimeofday(&end,NULL);
			printf("%ld seconds elapsed\n", end.tv_sec*1000000+(end.tv_usec)-start.tv_sec*1000000-(start.tv_usec));
			
			return (size*8-count);
/*
			add0:
				j=0;
				temp1=0;
				count=count+setbits(temp1);
				if(i<=size_l-off_n)
					goto cont0;		
				else 
					return (size*8-count);
*/		case 2:
			off_n=off>>3;
			a=vld1_u64(&circ_w[(*ptr_circ)++]);
			for(;*ptr_circ<size_l;){
				b=vld1_u64(&circ_w[(*ptr_circ)++]);
				temp=vorr_u64(vshr_n_u64(a,16),vshl_n_u64(b,48));
				c=veor_u64(vld1_u64(&ref_w[i++]),temp);
				count=count+setbits(c);
				a=b;
			}
			*ptr_circ=0;
                        for (;i<size_l;){		
				b=vld1_u64(&circ_w[(*ptr_circ)++]);
                                temp=vorr_u64(vshr_n_u64(a,16),vshl_n_u64(b,48));
                                c=veor_u64(vld1_u64(&ref_w[i++]),temp);
                                count=count+setbits(c);
				a=b;
			}
			return (size*8-count);
		case 4:
			off_n=off>>3;
                        a=vld1_u64(&circ_w[(*ptr_circ)++]);
                        for(;*ptr_circ<size_l;){
                                b=vld1_u64(&circ_w[(*ptr_circ)++]);
                                temp=vorr_u64(vshr_n_u64(a,32),vshl_n_u64(b,32));
                                c=veor_u64(vld1_u64(&ref_w[i++]),temp);
                                count=count+setbits(c);
				a=b;
                        } 
                        *ptr_circ=0;
                        for (;i<size_l;){ 
                                b=vld1_u64(&circ_w[(*ptr_circ)++]);
                                temp=vorr_u64(vshr_n_u64(a,32),vshl_n_u64(b,32));
                                c=veor_u64(vld1_u64(&ref_w[i++]),temp);
                                count=count+setbits(c);
				a=b;
                        }
			return (size*8-count);
		case 6:
			off_n=off>>3;
                        a=vld1_u64(&circ_w[(*ptr_circ)++]);
                        for(;*ptr_circ<size_l;){
                                b=vld1_u64(&circ_w[(*ptr_circ)++]);
                                temp=vorr_u64(vshr_n_u64(a,48),vshl_n_u64(b,16));
                                c=veor_u64(vld1_u64(&ref_w[i++]),temp);
                                count=count+setbits(c);
                                a=b;    
                        }       
                        *ptr_circ=0;
                        for (;i<size_l;){ 
                                b=vld1_u64(&circ_w[(*ptr_circ)++]);
                                temp=vorr_u64(vshr_n_u64(a,48),vshl_n_u64(b,16));
                                c=veor_u64(vld1_u64(&ref_w[i++]),temp);
                                count=count+setbits(c);
                                a=b;
                        }
                        return (size*8-count);
		default:
			printf("something gone wrong");
			return 0;
	}	
}

